# Simulation

## Simulation is the process of running our robot code on a computer other than the robot to test it without being limited by physical hardware

### overview

Generally speaking, simulation depends on sending the inputs we would like to test to a model of a system (mechanism) and analyzing the simulated results.
There are several ways to do this, depending on what you’re simulating.
This could be something small, like simulated readings of an encoder, or something more complex, like a physics simulation of an arm.
Simulation is important for a couple of reasons—we can test something without risking breaking an actual physical part, as well as being able to concurrently develop code as those physical components are being built (which is often the case during the build season).

### sim GUI

We have a number of tools at our disposal for simulation.
One is WPILib’s built-in desktop simulation.
This handles the process of sending inputs (from joysticks, widgets in the sim dashboard, etc) and running robot code on a computer.
This is the backbone of our simulation.

The sim graphical user interface (GUI) looks like this and can be launched through the WPILib command palette.

<img src="../../Assets/SimGUI.webp" alt="Screenshot of the sim GUI" width="600"/>

From here, you can view some interesting bits of information about your simulated robot, such as whether it's enabled or not, how long it's been up, joysticks, etc. More details are [here](https://docs.wpilib.org/en/stable/docs/software/wpilib-tools/robot-simulation/simulation-gui.html#using-the-gui).

Then we have WPILib’s simulation physics classes.
These are built around a state space model of a class of mechanism and exist for many common mechanisms to predict how they will behave.

<details>
<summary>Quick digression on state space</summary>

A state is a characteristic of a system at a certain point in time.
A vector is just a way to represent these states.
(If you aren't familiar with vectors/matrices, that's okay!)
For example, a drivetrain system might have the states $`\begin{bmatrix}x\\y\\\theta\end{bmatrix}`$ to describe its position on the field - the x is the x position, y is the y position, and $\theta$ is the rotation of the robot, all in a column vector.
A state-space model is a set of matrix equations that describe how a system changes over time by basically multiplying these state vectors by (scalar) inputs.

---
</details>


Like other simulated systems, the mechanism’s state is updated periodically with simulated inputs.
For example, we can simulate the change in position of an elevator when a certain voltage is applied to its motor using this mathematical model.

Sometimes these models will be very accurate.
Sometimes they will make a lot of untrue assumptions about the mechanism.
Both are useful, since we will likely have to retune the mechanism one way or another once we have real hardware.
Deciding how much effort to put into a simulation model is a key part of the intuition you will build as you code more robots.
We tend to use one or two of these per robot for major mechanisms.
If you want to learn more about this sort of modeling, look at the [control theory for FRC book](https://file.tavsys.net/control/controls-engineering-in-frc.pdf).
Note that the topics covered by this book are largely far more advanced than high schoolers have the math background for, and it is not required reading.

### AdvantageScope

Running a model is useful, but even more useful is being able to visualize the output of the model.
There are several dashboards you can use to do this, but we mainly use AdvantageScope.
[AdvantageScope](https://github.com/Mechanical-Advantage/AdvantageScope) is a tool developed by Team 6328 to visualize data from live robots, simulated robots, and robot logs.
It provides a variety of formats to visualize data. These applications include things like line graphs, 2d field modeling, 3d robot modeling, tables, timeline plots, custom widgets, and more. 

<img src="../../Assets/AdvantageScopeScreenshot.png" alt="Screenshot of Advantagescope" width="600"/>

This way we can run autonomous routines, drive around in sim, test mechanisms, and even run 3d calculations like localizing with april tags, all without requiring the robot. 

3d modeling requires us to import and configure any 3d CAD robot models and field components we want to use. Our team prefers this approach because it's helpful to visualise and test the full robot and all its components. In the simulator, both 2D and 3D geometry types are supported, such as, Pose2d, Pose3d, Translation2d, and Translation3d. 

It is closely integrated with AdvantageKit, a logging framework also from Team 6328, but does not require it.

- [general advantagescope documentation](https://docs.advantagescope.org/)
- [more details about the 3d field](https://docs.advantagescope.org/tab-reference/3d-field)
- [custom assets](https://docs.advantagescope.org/more-features/custom-assets)
- in order to implement these custom models CAD models with have to be converted into the gITF format, as cad isn't supported [tutorial](https://docs.advantagescope.org/more-features/gltf-convert)

### MapleSim
Our team also integrates MapleSim into the robot code. Maple sim supports more complex physics simulations. Maple sim allows us to represent motors, encoder, and sensors, instead of just modeling kinematics. This lets us test and tune the robot behavior in a more realistic way. 

[more details](https://shenzhen-robotics-alliance.github.io/maple-sim/)

### WPIlib Sim Classes
WPILib provides sim classes such as ElevatorSim and SingledJointedArmSIm. These require parameters such as gear ratios, mass, and motor types so the simulation knows how to behave. Once we set up the simulation we can use it to test our code against a virtual mechanism.

Go [here](https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj/simulation/package-summary.html) to check out the specific classes and methods

take a look at this quick example:
```Java
new ElevatorSim(
         DCMotor.getKrakenX60Foc(1), //gear box: type of motor and number of motors
         ElevatorSubsystem.GEAR_RATIO, //gearing: gear ratio
         Units.lbsToKilograms(7.0 + (3.25 / 2)), //carriage mass: mass of elevator carriage
         ElevatorSubsystem.DRUM_RADIUS_METERS, // drumRadiusMeters: radius of the drum the elevator spool is wrapped around
         0.0, // minHeightMeters: the minimum height
         ElevatorSubsystem.MAX_EXTENSION_METERS, // maxHeightMeters: the maxium height
         true, // simumateGravity: should gravity be simulated?
         0.0); //measurementStdDevs: standard deviation of measurements
```

### sim vs real

The final major tool is being able to swap between simulated inputs and outputs (IO) and real IO easily and correctly.
We will cover what this looks like with AdvantageKit [here](AdvantageKit.md), but at a high level, this means that we have both a sim and real version of each mechanism in our code.
This is so we can easily test our code in sim and have minimal work to move it to real hardware.

<details>
<summary>More details on Sim vs Real  implementation</summary>

The real IO layer controls the actual motors, sensors, and hardware on the robot. Sim IO replaces those with the simulated versions that approximate how the robot component should behave. The code structure differs because the real code deals with initializing, configuring, and driving hardware like Talons or CANcoders, while sim code uses simulation classes, like ELevatorSIm, to mimic their behavior. 

As you look through the code, you'll notice that real handles initializing motors, configurations, and hardware based commands, whereas sim uses methods from the sim classes. 

if you want to take a closer look at what the specific code looks like follow along with [this tutorial](Docs/2_Architecture/2.9_KitbotExampleWalkthroughSim.md) for kitBot sim

---
</details>

### Resources

- Read through the [WPILib docs intro to simulation](https://docs.wpilib.org/en/stable/docs/software/wpilib-tools/robot-simulation/introduction.html).
- Optional additional reading on [state space modeling](https://docs.wpilib.org/en/stable/docs/software/advanced-controls/state-space/state-space-intro.html)
- [WPILib simulations](https://github.wpilib.org/allwpilib/docs/release/java/edu/wpi/first/wpilibj/simulation/package-summary.html)

### Examples

- The [kitbot example code](../../Examples/KitbotDemoSim)

### Exercises

- Download and install [AdvantageScope](https://github.com/Mechanical-Advantage/AdvantageScope).
- Follow [this tutorial](Docs/2_Architecture/2.9_KitbotExampleWalkthroughSim.md) to convert your kitbot code to AdvantageKit and simulation.

### Notes

- Structuring a codebase to be simulatable is not an easy task.
 It is important to be familiar with the tools we have and stick to a clean structure to make it easy to simulate our code.
- Code that has been tested in sim does not necessarily work on the robot.
Be sure to stay safe and prepare for unexpected behavior when testing, especially for the first time.