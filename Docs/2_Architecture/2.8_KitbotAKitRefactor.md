# Kitbot, now with AdvantageKit

## Intro
We'll be applying what we just learned about AdvantageKit and how we structure our code with it to our kitbot code.

## Code Walkthrough

### Moving to AdvantageKit

The first step of moving our standard Command-based code to a loggable, simulateable structure is to install AdvantageKit.
Luckily AdvantageKit has a handy guide on how to install it on an existing code base.
Follow [this walkthrough](https://github.com/Mechanical-Advantage/AdvantageKit/blob/main/docs/INSTALLATION.md).
Follow all the steps in the doc through adding the `@AutoLog` annotation.

You do not need to add the suggested block in `Robot()`, instead use the one below.
The suggested logging configuration is built around replaying logs, while we just want to simulate code.

```Java
Logger.getInstance().recordMetadata("ProjectName", "KitbotExample"); // Set a metadata value

    if (isReal()) {
      Logger.getInstance().addDataReceiver(new WPILOGWriter("/media/sda1/")); // Log to a USB stick
      Logger.getInstance().addDataReceiver(new NT4Publisher()); // Publish data to NetworkTables
      new PowerDistribution(1, ModuleType.kRev); // Enables power distribution logging
    } else {
      Logger.getInstance().addDataReceiver(new NT4Publisher()); // Publish data to NetworkTables
    }

    Logger.getInstance().start(); // Start logging! No more data receivers, replay sources, or metadata values may be added.
```



Once you've completed this, it's time to break `DrivetrainSubsystem` appart using the IO layer structure.

### Refactoring `DrivetrainSubsystem`

Recall the [IO layer structure](https://github.com/Mechanical-Advantage/AdvantageKit/blob/main/docs/CODE-STRUCTURE.md) for robot code.
Right now we have one file for `DrivetrainSubsystem`.
Lets put it in a `Drivetrain` folder under `Subsystems` so that everything stays organized as we add more files.

![A screenshot showing the new folder](../../Assets/KitbotExampleSimScreenshot0.png)

Next, let's make a new file called `DrivetrainIO` in the same folder.
Remember that this file will define all the methods we use to interact with the hardware on the drivetrain.
You can use the "Create a new class/command" option when you right click on the folder to speed this up.
Make sure to change the type of `DrivetrainIO` to interface, not class.

```Java
package frc.robot.Subsystems.Drivetrain;

public interface DrivetrainIO {}
```

Inside of this interface lets define our `IOInputs` class.
Remember this is a container for all of the inputs (sensor readings) and outputs (motor commands) for this mechanism.

```Java
public static class DrivetrainIOInputs {}
```

Let's start by logging the output voltage of each side of the drivetrain.

```Java
public static class DrivetrainIOInputs {
    public double leftOutputVolts = 0.0;
    public double rightOutputVolts = 0.0;
}
```

Notice how we name our fields with units.
**It is very important to include units in all IOInputs variable names**.
It is very easy to assume different units in different places, which can cause frustrating and hard to find bugs.

Next lets log the current velocity of each side of the drivetrain.

```Java
public static class DrivetrainIOInputs {
    public double leftOutputVolts = 0.0;
    public double rightOutputVolts = 0.0;

    public double leftVelocityMetersPerSecond = 0.0;
    public double rightVelocityMetersPerSecond = 0.0;
}
```

Notice the units.
This field is useful both for being able to look at drivetrain performance but also for being able to track our position over time.
In fact, let's add a field for the current position of each side.

```Java
public static class DrivetrainIOInputs {
    // Snip
    public double leftPositionMeters = 0.0;
    public double rightPositionMeters = 0.0;
}
```

These values are useful for odometry.
Odometry is a way to track the robots position on the field by measuring how much each wheel is turning.
On a real robot we use it for auto so that we can draw paths on a map of the field instead of guessing where the robot should go.
For this sim we will use odometry to give us a position that we can use to visualize the robot on a fake field.

On a real robot it can be useful to log motor current draw and temperature.
Current draw is the amount of power the motor is actually using to try to reach it's desired output, and is measured in Amperes or amps.
The amount of power flowing through these motors also causes them to heat up over the course of a match.
When the motors get hotter, they get less efficient.
Logging the temparature of our motors can help us debug mechanisms which have problems near the end of a match.
Normally this issue is not too pronounced over the course of a single match.
However, in elims where we have a number of intense matches back to back or during drive practice where we run continuously for hours this can become an issue.
This simulation will not include temperature simulation, but it's good to get into the habit of including it in your logged values.

```Java
public static class DrivetrainIOInputs {
    // Snip
    public double leftCurrentAmps = 0.0;
    public double leftTempCelsius = 0.0;
    public double rightCurrentAmps = 0.0;
    public double rightTempCelsius = 0.0;
}
```

Seeing as we only have 1 motor on each side for this example, it makes more sense to leave these as doubles.
However, if you have multiple motors per side, you may want to make these arrays of doubles.

Finally to finish this IOInputs class we need to add the `@AutoLog` annotation above its definition.
This annotation automatically generates code to convert these values to a loggable format and back.
However it is limited to only certain types of values, so be careful when making IOInputs classes.
If you want to log other types than `@AutoLog` supports you can follow the [AdvantageKit docs example](https://github.com/Mechanical-Advantage/AdvantageKit/blob/main/docs/CODE-STRUCTURE.md#autolog-annotation) on it.

Next, we need to add a method called `updateInputs` that takes in the `IOInputs` object and updates it based off of the new values from our sensors.

```Java
public void updateInputs(DrivetrainIOInputs inputs);
```

Finally, let's add the methods that we use to interact with the hardware.
For this case it will just be a method `setVolts` to set the left and right output volts, like our `setVoltages` method that we have right now.

Now your `DrivetrainIO` file should look like this:

```Java
package frc.robot.Subsystems.Drivetrain;

import org.littletonrobotics.junction.AutoLog;

public interface DrivetrainIO {
    @AutoLog
    public static class DrivetrainIOInputs {
        public double leftOutputVolts = 0.0;
        public double rightOutputVolts = 0.0;

        public double leftVelocityMetersPerSecond = 0.0;
        public double rightVelocityMetersPerSecond = 0.0;

        public double leftPositionMeters = 0.0;
        public double rightPositionMeters = 0.0;

        public double leftCurrentAmps = 0.0;
        public double leftTempCelsius = 0.0;
        public double rightCurrentAmps = 0.0;
        public double rightTempCelsius = 0.0;
    }

    public abstract void updateInputs(DrivetrainIOInputs inputs);

    public abstract void setVolts(double left, double right);
}
```

Next, let's add the IO Implementation.
This will be a file that defines the `updateInputs()` and `setVolts()` method.

Start by making a new class called `DrivetrainIOReal` in the Drivetrain folder.

Then, add `implements DrivetrainIO` to the class declaration.
This is very similar to using `extends`, except for interfaces instead of classes.
This means we could have multiple interfaces it implements, instead of just one class.

```Java
public class DrivetrainIOReal implements DrivetrainIO {}
```

This will make vscode angry since `DrivetrainIOReal` needs to implement all the abstract methods in `DrivetrainIO`.
Hover over it, hit "quick fix", and click "add unimplemented methods".
Now you should have a template for both of these methods.

```Java
public class DrivetrainIOReal implements DrivetrainIO {

    @Override
    public void updateInputs(DrivetrainIOInputs inputs) {
        // TODO Auto-generated method stub

    }

    @Override
    public void setVolts(double left, double right) {
        // TODO Auto-generated method stub

    }
}
```

Before we get into implementing these, we need to add the hardware to this IO Implementation.
Add in the falcons from `DrivetrainSubsystem`.

```Java
TalonFX leftFalcon = new TalonFX(Constants.drivetrainLeftFalconID);
TalonFX rightFalcon = new TalonFX(Constants.drivetrainRightFalconID);
```

Let's add all of the needed fields to `updateInputs`, even though we won't be able to set any of them yet.
One way to get all of the needed fields is to copy and paste the body of `DrivetrainIOInputs` into `updateInputs`.

```Java
@Override
public void updateInputs(DrivetrainIOInputs inputs) {
    public double leftOutputVolts = 0.0;
    public double rightOutputVolts = 0.0;

    public double leftVelocityMetersPerSecond = 0.0;
    public double rightVelocityMetersPerSecond = 0.0;

    public double leftPositionMeters = 0.0;
    public double rightPositionMeters = 0.0;

    public double leftCurrentAmps = 0.0;
    public double leftTempCelsius = 0.0;
    public double rightCurrentAmps = 0.0;
    public double rightTempCelsius = 0.0;
}
```

Then replace the `public` and types with `inputs.`

```Java
@Override
public void updateInputs(DrivetrainIOInputs inputs) {
    inputs.leftOutputVolts = 0.0;
    inputs.rightOutputVolts = 0.0;

    inputs.leftVelocityMetersPerSecond = 0.0;
    inputs.rightVelocityMetersPerSecond = 0.0;

    inputs.leftPositionMeters = 0.0;
    inputs.rightPositionMeters = 0.0;

    inputs.leftCurrentAmps = 0.0;
    inputs.leftTempCelsius = 0.0;
    inputs.rightCurrentAmps = 0.0;
    inputs.rightTempCelsius = 0.0;
}
```

Now, how do we get these values?
The `StatusSignal` class is how we can get live data reported by a CTRE device, like position, velocity, etc.
Here, we'll be looking at the values we get from a TalonFX, but you can also get useful `StatusSignal`s from Pigeons, CANcoders, etc.
We'll update these every loop to get the latest data from each device.

Which `StatusSignal` we use depends on what data we want to collect.
Since we want to know the voltage draw of the left and right motors, we will need 2 `StatusSignal<Voltage>`s.
We'll define these member variables at the top of `DrivetrainIOReal`.

```Java
public class DrivetrainIOReal implements DrivetrainIO {
    TalonFX leftFalcon = new TalonFX(Constants.drivetrainLeftFalconID);
    TalonFX rightFalcon = new TalonFX(Constants.drivetrainRightFalconID);
    
    private final StatusSignal<Voltage> leftAppliedVoltage;
    private final StatusSignal<Voltage> rightAppliedVoltage;
}
```

Then, we'll instantiate these signals and match them to the correct motors + signal type.
Call `.getMotorVoltage();` on both of these motors, which returns a `StatusSignal<Voltage>,` and assign that to their respective signals.

```Java
public class DrivetrainIOReal implements DrivetrainIO {
    TalonFX leftFalcon = new TalonFX(Constants.drivetrainLeftFalconID);
    TalonFX rightFalcon = new TalonFX(Constants.drivetrainRightFalconID);
    
    private final StatusSignal<Voltage> leftAppliedVoltage = leftFalcon.getMotorVoltage();
    private final StatusSignal<Voltage> rightAppliedVoltage = rightFalcon.getMotorVoltage();
}
```

Go ahead and fill out the rest of the status signals in the same way.

```Java
public class DrivetrainIOReal implements DrivetrainIO {
    TalonFX leftFalcon = new TalonFX(Constants.drivetrainLeftFalconID);
    TalonFX rightFalcon = new TalonFX(Constants.drivetrainRightFalconID);
    
    private final StatusSignal<Voltage> leftAppliedVoltage = leftFalcon.getMotorVoltage();
    private final StatusSignal<Voltage> rightAppliedVoltage = rightFalcon.getMotorVoltage();
    private final StatusSignal<AngularVelocity> leftAngularVelocityRPS = leftFalcon.getVelocity();
    private final StatusSignal<AngularVelocity> rightAngularVelocityRPS = rightFalcon.getVelocity();

    // A little hacky - the units don't match, but that would typically be handled in the 
    // SensorToMechanismRatio config. For the purposes of this lesson, you do not need to
    // worry about this. Ask a lead if you have questions!
    private final StatusSignal<Angle> leftPositionMeters = leftFalcon.getPosition(); 
    private final StatusSignal<Angle> rightPositionMeters = rightFalcon.getPosition(); 

    private final StatusSignal<Current> leftSupplyCurrent = leftFalcon.getSupplyCurrent();
    private final StatusSignal<Current> rightSupplyCurrent = rightFalcon.getSupplyCurrent();
    private final StatusSignal<Temperature> leftTempCelsius = leftFalcon.getDeviceTemp();
    private final StatusSignal<Temperature> rightTempCelsius = rightFalcon.getDeviceTemp();
}
```
The values of these signals will need to be updated every loop (every 20 milliseconds, which equals 50 hertz).
This will need to be set in the `DrivetrainIOReal` constructor, so that it will get called when a new drivetrain object is created.

```Java
public DrivetrainIOReal() {
    // Sets the following status signals to be updated at a frequency of 50hz
    BaseStatusSignal.setUpdateFrequencyForAll(
        50.0, // update every 20ms
        leftAppliedVoltage, 
        rightAppliedVoltage, 
        leftAngularVelocityRPS, 
        rightAngularVelocityRPS, 
        leftPositionMeters, 
        rightPositionMeters, 
        leftSupplyCurrent, 
        rightSupplyCurrent, 
        leftTempCelsius, 
        rightTempCelsius);
}
```

At the top of `updateInputs()` (which gets called periodically), we're going to refresh all these signals with the `BaseStatusSignal.refreshAll()` method.
We'll pass in all our status signals as parameters.

```Java
@Override
public void updateInputs(DrivetrainIOInputs inputs) {
    BaseStatusSignal.refreshAll(leftAppliedVoltage, 
        rightAppliedVoltage, 
        leftAngularVelocityRPS, 
        rightAngularVelocityRPS, 
        leftPositionMeters, 
        rightPositionMeters, 
        leftSupplyCurrent, 
        rightSupplyCurrent, 
        leftTempCelsius, 
        rightTempCelsius);
}
```
Now that we have the latest data for all these signals, we can log them.
Let's get those values and set the corresponding fields in `inputs` equal to them.
You'll need to call some sort of `.getValueAsDouble()` on these signals, since we can't use the `StatusSignal` directly.
You might also need to then create a new `Rotation2d` or something similar from that depending on what the field is.

```Java
@Override
public void updateInputs(DrivetrainIOInputs inputs) {
    BaseStatusSignal.refreshAll(leftAppliedVoltage, 
        rightAppliedVoltage, 
        leftAngularVelocityRPS, 
        rightAngularVelocityRPS, 
        leftPositionMeters, 
        rightPositionMeters, 
        leftSupplyCurrent, 
        rightSupplyCurrent, 
        leftTempCelsius, 
        rightTempCelsius);

    inputs.leftOutputVolts = leftAppliedVoltage.getValueAsDouble();
    inputs.rightOutputVolts = rightAppliedVoltage.getValueAsDouble();

    inputs.leftVelocityMetersPerSecond = leftAngularVelocityRPS.getValueAsDouble();
    inputs.rightVelocityMetersPerSecond = rightAngularVelocityRPS.getValueAsDouble();

    inputs.leftPositionMeters = leftPositionMeters.getValueAsDouble();
    inputs.rightPositionMeters = rightPositionMeters.getValueAsDouble();

    inputs.leftCurrentAmps = leftSupplyCurrent.getValueAsDouble();
    inputs.leftTempCelsius = rightSupplyCurrent.getValueAsDouble();
    inputs.rightCurrentAmps = rightSupplyCurrent.getValueAsDouble();
    inputs.rightTempCelsius = rightTempCelsius.getValueAsDouble();

}
```
Your `DrivetrainIOReal` class is now complete!

Let's refactor our `DrivetrainSubsystem` to finish off this rewrite.

First, we need to replace all the functionality that moved to `DrivetrainIOReal` with an instance of `DrivetrainIOReal`.
Get rid of the `TalonFX` objects and `VoltageOut` requests.

```Java
public class DrivetrainSubsystem extends SubsystemBase {
    DrivetrainIO io = new DrivetrainIOReal();
    // Snip
}
```

Then we should add an `IOInputs` object to track the inputs to the subsystem.
There's a catch though: since we used `@AutoLog` we have to use `DrivetrainIOInputsAutoLogged`, otherwise it won't properly log.

```Java
public class DrivetrainSubsystem extends SubsystemBase {
    DrivetrainIO io = new DrivetrainIOReal();
    DrivetrainIOInputsAutoLogged inputs = new DrivetrainIOInputsAutoLogged();
}
```

Now we need to finish the AdvantageKit IO setup.
Add a call to `io.updateInputs(inputs)` in the `periodic()` method of `DrivetrainSubsystem`.

```Java
@Override
public void periodic() {
    io.updateInputs(inputs);
}
```

Then we need to push those inputs to the log.
We do this by calling `Logger.getInstance().processInputs("Drivetrain", inputs)`.

```Java
@Override
public void periodic() {
    io.updateInputs(inputs);
    Logger.getInstance().processInputs("Drivetrain", inputs);
}
```

Finally, let's change the `setVoltages` method to use the io layer.

```Java
private void setVoltages(double left, double right) {
    io.setVolts(left, right);
}
```

And that's basically it!
In a future lesson, you'll learn how to simulate all of this as well.

This general structure of motors/other devices -> `ControlRequest`s and `StatusSignal`s -> various methods + `updateInputs()` is important and used across mechanisms, so use this to guide you as you write more mechanisms in the future.